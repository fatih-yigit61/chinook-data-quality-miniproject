use Chinook;

-- ---------------------------------------------------------------------------------------
-- scenario: playlist revenue potential
-- description: calculate the total revenue generated by each playlist based on track sales.
-- insight: identifies playlists that contain high-selling tracks, representing high engagement potential.
-- ---------------------------------------------------------------------------------------

select 
    p.PlaylistId,
    p.Name as PlaylistName,
    count(pt.TrackId) as TrackCount,
    sum(il.UnitPrice * il.Quantity) as TotalPlaylistRevenue
from Playlist p
join PlaylistTrack pt on p.PlaylistId = pt.PlaylistId
join Track t on pt.TrackId = t.TrackId
left join InvoiceLine il on t.TrackId = il.TrackId
group by p.PlaylistId, p.Name
order by TotalPlaylistRevenue desc;


-- ---------------------------------------------------------------------------------------
-- scenario: genre diversity in playlists
-- description: measures the number of unique genres in each playlist.
-- insight: reveals how musically diverse each playlist is.
-- ---------------------------------------------------------------------------------------

select 
    p.PlaylistId,
    p.Name as PlaylistName,
    count(distinct t.GenreId) as GenreVariety
from Playlist p
join PlaylistTrack pt on p.PlaylistId = pt.PlaylistId
join Track t on pt.TrackId = t.TrackId
group by p.PlaylistId, p.Name
order by GenreVariety desc;


-- ---------------------------------------------------------------------------------------
-- scenario: playlist quality score (heuristic model)
-- description: calculates a composite score for playlists based on size, genre variety, 
--              total revenue, and duration consistency.
-- insight: helps identify high-quality playlists using weighted metrics.
-- ---------------------------------------------------------------------------------------

with Base as (
    select 
        p.PlaylistId,
        p.Name as PlaylistName,
        count(distinct pt.TrackId) as TrackCount,
        count(distinct t.GenreId) as GenreDiversity,
        round(isnull(stdevp(t.Milliseconds), 0), 2) as DurationVariance,
        sum(isnull(il.UnitPrice * il.Quantity, 0)) as TotalRevenue
    from Playlist p
    join PlaylistTrack pt on p.PlaylistId = pt.PlaylistId
    join Track t on pt.TrackId = t.TrackId
    left join InvoiceLine il on t.TrackId = il.TrackId
    group by p.PlaylistId, p.Name
)
select *,
    round(
        (TrackCount * 0.4) +
        (GenreDiversity * 0.3) +
        (TotalRevenue / 10 * 0.2) -
        (DurationVariance / 60000.0 * 0.1), 2
    ) as QualityScore
from Base
order by QualityScore desc;


-- ---------------------------------------------------------------------------------------
-- scenario: metadata completeness check
-- description: count how many tracks in each playlist have missing genre, album, or artist info.
-- insight: playlists with incomplete metadata might need cleanup or data validation.
-- ---------------------------------------------------------------------------------------

select 
    p.PlaylistId,
    p.Name as PlaylistName,
    count(*) as ProblematicTrackCount
from Playlist p
join PlaylistTrack pt on p.PlaylistId = pt.PlaylistId
join Track t on pt.TrackId = t.TrackId
left join Album al on t.AlbumId = al.AlbumId
left join Artist ar on al.ArtistId = ar.ArtistId
where t.GenreId is null or t.AlbumId is null or ar.ArtistId is null
group by p.PlaylistId, p.Name
order by ProblematicTrackCount desc;



-- ---------------------------------------------------------------------------------------
-- scenario: dominant genre in each playlist
-- description: identify the most frequently appearing genre in each playlist.
-- insight: shows the main musical theme or focus of a playlist.
-- ---------------------------------------------------------------------------------------

with GenreCount as (
    select 
        p.PlaylistId,
        p.Name as PlaylistName,
        g.Name as GenreName,
        count(*) as GenreTrackCount,
        row_number() over (partition by p.PlaylistId order by count(*) desc) as GenreRank
    from Playlist p
    join PlaylistTrack pt on p.PlaylistId = pt.PlaylistId
    join Track t on pt.TrackId = t.TrackId
    join Genre g on t.GenreId = g.GenreId
    group by p.PlaylistId, p.Name, g.Name
)
select PlaylistId, PlaylistName, GenreName as DominantGenre, GenreTrackCount
from GenreCount
where GenreRank = 1
order by PlaylistName;


-- ---------------------------------------------------------------------------------------
-- scenario: playlist balance score
-- description: heuristic score to measure playlist balance in terms of diversity and track duration consistency.
-- insight: a well-balanced playlist mixes variety with consistent listening experience.
-- ---------------------------------------------------------------------------------------

with Balance as (
    select 
        p.PlaylistId,
        p.Name as PlaylistName,
        count(distinct t.GenreId) as GenreDiversity,
        count(distinct ar.ArtistId) as ArtistDiversity,
        stdevp(t.Milliseconds) as DurationVariance
    from Playlist p
    join PlaylistTrack pt on p.PlaylistId = pt.PlaylistId
    join Track t on pt.TrackId = t.TrackId
    join Album al on t.AlbumId = al.AlbumId
    join Artist ar on al.ArtistId = ar.ArtistId
    group by p.PlaylistId, p.Name
)
select *,
    round(
        (GenreDiversity * 0.4) +
        (ArtistDiversity * 0.4) -
        (DurationVariance / 60000.0 * 0.2), 2
    ) as BalanceScore
from Balance
order by BalanceScore desc;


-- ---------------------------------------------------------------------------------------
-- scenario: playlists with high-revenue unique tracks
-- description: highlight playlists that contain tracks generating high revenue but not widely reused in other playlists.
-- insight: promotes rare but valuable content.
-- ---------------------------------------------------------------------------------------


with TrackUsage as (
    select TrackId, count(distinct PlaylistId) as PlaylistAppearances
    from PlaylistTrack
    group by TrackId
),
RevenuePerTrack as (
    select 
        t.TrackId,
        t.Name as TrackName,
        sum(il.UnitPrice * il.Quantity) as TrackRevenue
    from Track t
    left join InvoiceLine il on t.TrackId = il.TrackId
    group by t.TrackId, t.Name
),
TrackQuality as (
    select 
        pu.PlaylistId,
        pu.TrackId,
        r.TrackRevenue,
        u.PlaylistAppearances
    from PlaylistTrack pu
    join RevenuePerTrack r on pu.TrackId = r.TrackId
    join TrackUsage u on pu.TrackId = u.TrackId
)
select 
    pl.PlaylistId,
    pl.Name as PlaylistName,
    round(avg(tq.TrackRevenue), 2) as AvgTrackRevenue,
    round(avg(tq.TrackRevenue / nullif(tq.PlaylistAppearances, 0)), 2) as RevenuePerPlaylistUse
from TrackQuality tq
join Playlist pl on tq.PlaylistId = pl.PlaylistId
group by pl.PlaylistId, pl.Name
order by RevenuePerPlaylistUse desc;






-- ---------------------------------------------------------------------------------------
-- scenario: tracks with incomplete metadata inside playlists
-- description: detect tracks within playlists that are missing critical metadata like genre, album, or artist.
-- insight: incomplete metadata in playlists can degrade user experience and prevent accurate filtering or recommendations.
-- ---------------------------------------------------------------------------------------

select 
    p.PlaylistId,
    p.Name as PlaylistName,
    t.TrackId,
    t.Name as TrackName,
    case 
        when t.GenreId is null and t.AlbumId is null then 'missing genre & album'
        when t.GenreId is null then 'missing genre'
        when t.AlbumId is null then 'missing album'
        else 'complete'
    end as MetadataStatus
from Playlist p
join PlaylistTrack pt on p.PlaylistId = pt.PlaylistId
join Track t on pt.TrackId = t.TrackId
left join Album al on t.AlbumId = al.AlbumId
left join Artist ar on al.ArtistId = ar.ArtistId
where t.GenreId is null or t.AlbumId is null or ar.ArtistId is null
order by p.PlaylistId, MetadataStatus;



-- ---------------------------------------------------------------------------------------
-- scenario: revenue concentration by top tracks per playlist
-- description: measure how much of a playlist's total revenue comes from its top-earning track.
-- insight: playlists where revenue is dominated by one track may lack depth or balance.
-- ---------------------------------------------------------------------------------------

with TrackRevenueInPlaylist as (
    select 
        pt.PlaylistId,
        p.Name as PlaylistName,
        t.TrackId,
        t.Name as TrackName,
        sum(isnull(il.UnitPrice * il.Quantity, 0)) as TrackRevenue
    from PlaylistTrack pt
    join Playlist p on pt.PlaylistId = p.PlaylistId
    join Track t on pt.TrackId = t.TrackId
    left join InvoiceLine il on t.TrackId = il.TrackId
    group by pt.PlaylistId, p.Name, t.TrackId, t.Name
),
Ranked as (
    select *,
        sum(TrackRevenue) over (partition by PlaylistId) as PlaylistTotalRevenue,
        rank() over (partition by PlaylistId order by TrackRevenue desc) as TrackRank
    from TrackRevenueInPlaylist
),
TopRevenueRatio as (
    select 
        PlaylistId,
        PlaylistName,
        PlaylistTotalRevenue,
        max(case when TrackRank = 1 then TrackRevenue else 0 end) as TopTrackRevenue
    from Ranked
    group by PlaylistId, PlaylistName, PlaylistTotalRevenue
)
select 
    PlaylistId,
    PlaylistName,
    PlaylistTotalRevenue,
    TopTrackRevenue,
    round(100.0 * TopTrackRevenue / nullif(PlaylistTotalRevenue, 0), 2) as TopTrackRevenuePercentage
from TopRevenueRatio
order by TopTrackRevenuePercentage desc;



-- ---------------------------------------------------------------------------------------
-- scenario: average track age in playlists
-- description: calculate how old (on average) the tracks in each playlist are based on album release date.
-- insight: reveals whether a playlist leans towards classic/older tracks or newer content, which can guide personalization or marketing.
-- ---------------------------------------------------------------------------------------

with TrackAge as (
    select 
        pt.PlaylistId,
        p.Name as PlaylistName,
        t.TrackId,
        al.Title as AlbumTitle,
        al.AlbumId,
        al.AlbumId * 1.0 as AlbumNumericValue  
    from PlaylistTrack pt
    join Playlist p on pt.PlaylistId = p.PlaylistId
    join Track t on pt.TrackId = t.TrackId
    join Album al on t.AlbumId = al.AlbumId
)
select 
    PlaylistId,
    PlaylistName,
    round(avg(AlbumNumericValue), 2) as AvgAlbumIdAsAgeProxy
from TrackAge
group by PlaylistId, PlaylistName
order by AvgAlbumIdAsAgeProxy;
